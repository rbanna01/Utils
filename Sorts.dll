using System;

namespace Utils {

	public class Sorts {
		//to do: selection, insertion,bubble, shell merge,quick, and optimized versions
		//modify for inverted sort? All in-place
		int[] material;
		//check whether top-down or bottom-up faster
		public void MergeSort(int[] input) {
			//need to work with indices
			Merge (input, 0, input.Length-1);
			}

		private void Merge(int[] toSort, int lo, int hi) {
			if (hi - lo == 1) {
				if (toSort [hi] < toSort [lo])
					Swap (toSort, hi, lo);
			} else {
				Merge (toSort, lo, hi - lo / 2);
				Merge (toSort, hi - lo / 2, hi);
				int mid = hi - lo / 2;
				int x = lo;
				int y = mid;
				while (x < hi && y < hi) {
					//can be thought of as insertion sort; one is sorted, so if one lower need to shuffle
					//find first difference, then insert?
					//use lowest
					if (x > y) {//misses comparison of mid to mid-1
						int temp = x;
						x = y;
						y = temp;
					}
					if (toSort [x] > toSort [y]) { //when y hits hi?
						int temp = toSort[y];
						for (int i = y; i > x; i--) {
							toSort [i] = toSort [i-1];
						}
						toSort [x] = temp;
						y++;

						/*
					Swap (toSort, x, y);
					x++; //can be considered sorted now, having been checked against x and y */


					} else
						x++;
				} //ends for 
			}
			//here: merge up
		} //ends Merge

		/*  Conventional merge with another array
		 * for (int i = 0; i < material.Length; i++) {
				if (x >= mid) {
					while (y <= hi) {
						material [i] = toSort [y];
					    y++;
					}
					break;
				} else if (y > hi) {
					while (x < mid) {
						material [i] = toSort [x];
						x++;
						}
					break;
				}
				else if (toSort [x] < toSort [y]) {
					material [i] = toSort [x];
					x++;
				} else {
					material [i] = toSort [y];
					y++;
				}
			}*/
		


		public void SelectionSort(int[] input) {
			//in-place
			int hi;
			for (int i =input.Length-1; i >0; i--) {
				hi = 0;
				for (int j = 1; j <= i; j++) {
					if (input [j] > input [hi]) {
						hi = j;
					}
				} //ends inner for
				Swap (input, i, hi);
			} //ends outer for
		}

		public void InsertionSort(int[] input) {
			for (int i = 1; i < input.Length; i++) {
				for (int j = 0; j < i; j++) {
					if (input [j] > input [i]) {
						int temp = input [i];
						for (int k = j+1; k <= i; k++) {
							input [k] = input [k - 1];
						} //ends shifting for
						input [j] = temp;
					}//if
				} //inner for
			} // outer for

		} //ends InsertionSort
		//to do: optimize
		public void BubbleSort(int[] input) {
			for (int i = input.Length-1; i >0; i--) {
				for (int j = 0; j < i; j++) {
					if (input [j] > input [j + 1]) {
						Swap (input, j, (j + 1));
					}
				}
			}
		}

		public void ShellSort(int[] input) {
			//deciding on number of passes?
			//sequence of increments: 3n+1 in reverse order
			//(3^k-1)/2, not greater than Ceiling(n/3)
			double max = Math.Ceiling( (double) input.Length / 3);
			int[] increments = new int[ (int)max];
			for (int i = 1; i < max; i++) {
				//increments [i] = ((Math.Power (3, i) - 1) / 2);//todo: check this library call
			}
			for (int i = increments.Length-1; i >= 0; i++) {
				//insertion sort over increments. Just extract and sort subarrays?
				int size = input.Length/increments[i]; //not right
			}

		} //ends ShellSort


		private void Swap(int[] input, int x, int y) {
			int temp = input [x];
			input [x] = input [y];
			input [y] = temp;
		}


		public static void Main(string[] args) {
			//test: random array of length 100?
			Sorts s = new Sorts ();
			/*s.InsertionSortTest ();
			s.SelectionSortTest ();
			s.BubbleSortTest ();*/
			s.MergeTest ();
			}

		//todo: apply. Test is good.
		public void MergeTest() {
			
			//probably too slow compared to just using another array
			int[] toSort = { 2, 3, 4, 1, 2, 6};
			int hi = toSort.Length - 1;
			int lo = 0;
			material = new int[toSort.Length];
			int mid = toSort.Length / 2;
			int x = lo;
			int y = mid;
			while (x < hi && y < hi) {
				//can be thought of as insertion sort; one is sorted, so if one lower need to shuffle
				//find first difference, then insert?
				//use lowest
				if (x > y) {//misses comparison of mid to mid-1
					int temp = x;
					x = y;
					y = temp;
				}
				if (toSort [x] > toSort [y]) { //when y hits hi?
					int temp = toSort[y];
					for (int i = y; i > x; i--) {
						toSort [i] = toSort [i-1];
					}
					toSort [x] = temp;
					y++;

					/*
					Swap (toSort, x, y);
					x++; //can be considered sorted now, having been checked against x and y */


				} else
					x++;
			} //ends sort for

		 /*	for (int i = 0; i < material.Length; i++) {
				if (x >= mid) {
					while (y <= hi) {
						material [i] = toSort [y];
					    y++;
					}
					break;
				} else if (y > hi) {
					while (x < mid) {
						material [i] = toSort [x];
						x++;
						}
					break;
				}
				else if (toSort [x] < toSort [y]) {
					material [i] = toSort [x];
					x++;
				} else {
					material [i] = toSort [y];
					y++;
				}
			}*/
			for (int i = 0; i < toSort.Length; i++) {
				Console.WriteLine (toSort [i]);
			}
		}



		public void InsertionSortTest() {
			int[] material = InitMaterial ();
			InsertionSort (material);
			if (!CheckMaterial ()) {
				PrintMaterial ();
			}
		}

		public void SelectionSortTest() {
			material = InitMaterial ();
			SelectionSort (material);
			if (!CheckMaterial ()) {
				PrintMaterial ();
			}
		}

		public void BubbleSortTest() {
			material = InitMaterial ();
			BubbleSort (material);
			if (!CheckMaterial ()) {
				PrintMaterial ();
			}
		}



		private bool CheckMaterial() {
			//checking: assume every number greater than one before
			for (int i = 1; i < material.Length; i++) {
				if (material [i] >= material [i - 1])
					continue; //output entire array
				else {
					return false;
				}
			} //ends for
			return true;

		} //ends CheckMaterial
		//ideally, would have string with name of method as argument obtained using reflection
		private void PrintMaterial() {
			Console.WriteLine ("Sort gives wrong results");
			string output = "";
			for (int i = 0; i < material.Length; i++) {
				output += material [i] + " ";

			}
			Console.WriteLine (output);
		}

		private int[] InitMaterial() {
			int[] material = new int[100];
			Random r = new Random ();
			for (int i = 0; i < 100; i++) {
				material [i] = r.Next (100);
			} //ends for
			return material;
		} //ends InitMaterial
	}


}
